/*
 * This file is part of the AzerothCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation; either version 3 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "Common.h"
#include "Item.h"
#include "Log.h"
#include "ObjectAccessor.h"
#include "ObjectMgr.h"
#include "Opcodes.h"
#include "Player.h"
#include "ScriptMgr.h"
#include "SpellInfo.h"
#include "SpellMgr.h"
#include "UpdateData.h"
#include "WorldPacket.h"
#include "WorldSession.h"

void WorldSession::HandleSplitItemOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_SPLIT_ITEM");
    uint8 srcbag, srcslot, dstbag, dstslot;
    uint32 count;

    recvData >> srcbag >> srcslot >> dstbag >> dstslot >> count;

    uint16 src = ((srcbag << 8) | srcslot);
    uint16 dst = ((dstbag << 8) | dstslot);

    if (src == dst)
        return;

    if (count == 0)
        return;                                             //check count - if zero it's fake packet

    if (!_player->IsValidPos(srcbag, srcslot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
        return;
    }

    if (!_player->IsValidPos(dstbag, dstslot, false))       // can be autostore pos
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, nullptr, nullptr);
        return;
    }

    _player->SplitItem(src, dst, count);
}

void WorldSession::HandleSwapInvItemOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_SWAP_INV_ITEM");
    uint8 srcslot, dstslot;

    recvData >> dstslot >> srcslot;

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (srcslot == dstslot)
        return;

    if (!_player->IsValidPos(INVENTORY_SLOT_BAG_0, srcslot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
        return;
    }

    if (!_player->IsValidPos(INVENTORY_SLOT_BAG_0, dstslot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, nullptr, nullptr);
        return;
    }

    if (_player->IsBankPos(INVENTORY_SLOT_BAG_0, srcslot) && !CanUseBank())
    {
        //LOG_DEBUG("network", "WORLD: HandleSwapInvItemOpcode - Unit ({}) not found or you can't interact with him.", m_currentBankerGUID.ToString());
        return;
    }

    if (_player->IsBankPos(INVENTORY_SLOT_BAG_0, dstslot) && !CanUseBank())
    {
        //LOG_DEBUG("network", "WORLD: HandleSwapInvItemOpcode - Unit ({}) not found or you can't interact with him.", m_currentBankerGUID.ToString());
        return;
    }

    uint16 src = ((INVENTORY_SLOT_BAG_0 << 8) | srcslot);
    uint16 dst = ((INVENTORY_SLOT_BAG_0 << 8) | dstslot);

    _player->SwapItem(src, dst);
}

void WorldSession::HandleAutoEquipItemSlotOpcode(WorldPacket& recvData)
{
    ObjectGuid itemguid;
    uint8 dstslot;
    recvData >> itemguid >> dstslot;

    // cheating attempt, client should never send opcode in that case
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, dstslot))
        return;

    Item* item = _player->GetItemByGuid(itemguid);
    uint16 dstpos = dstslot | (INVENTORY_SLOT_BAG_0 << 8);

    if (!item || item->GetPos() == dstpos)
        return;

    _player->SwapItem(item->GetPos(), dstpos);
}

void WorldSession::HandleSwapItem(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_SWAP_ITEM");
    uint8 dstbag, dstslot, srcbag, srcslot;

    recvData >> dstbag >> dstslot >> srcbag >> srcslot;

    uint16 src = ((srcbag << 8) | srcslot);
    uint16 dst = ((dstbag << 8) | dstslot);

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (src == dst)
        return;

    if (!_player->IsValidPos(srcbag, srcslot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
        return;
    }

    if (!_player->IsValidPos(dstbag, dstslot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, nullptr, nullptr);
        return;
    }

    if (_player->IsBankPos(srcbag, srcslot) && !CanUseBank())
    {
        //LOG_DEBUG("network", "WORLD: HandleSwapItem - Unit ({}) not found or you can't interact with him.", m_currentBankerGUID.ToString());
        return;
    }

    if (_player->IsBankPos(dstbag, dstslot) && !CanUseBank())
    {
        //LOG_DEBUG("network", "WORLD: HandleSwapItem - Unit ({}) not found or you can't interact with him.", m_currentBankerGUID.ToString());
        return;
    }

    _player->SwapItem(src, dst);
}

void WorldSession::HandleAutoEquipItemOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_AUTOEQUIP_ITEM");
    uint8 srcbag, srcslot;

    recvData >> srcbag >> srcslot;

    Item* pSrcItem  = _player->GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
        return;                                             // only at cheat

    ItemTemplate const* pProto = pSrcItem->GetTemplate();
    if (!pProto)
    {
        _player->SendEquipError(pSrcItem->IsBag() ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_ITEMS_CANT_BE_SWAPPED, pSrcItem);
        return;
    }

    uint8 eslot = _player->FindEquipSlot(pProto, NULL_SLOT, !pSrcItem->IsBag());
    if (eslot == NULL_SLOT)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_CANT_BE_EQUIPPED, pSrcItem);
        return;
    }

    uint16 src = pSrcItem->GetPos();
    uint16 dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
    if (dest == src) // prevent equip in same slot, only at cheat
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_CANT_BE_EQUIPPED, pSrcItem);
        return;
    }

    Item* pDstItem = _player->GetItemByPos(dest);

    // Remove item enchantments for now and restore it later
    // Needed for swap sanity checks
    if (pDstItem)
    {
        _player->ApplyEnchantment(pDstItem, false);
    }

    InventoryResult msg = _player->CanEquipItem(NULL_SLOT, dest, pSrcItem, !pSrcItem->IsBag());
    if (msg != EQUIP_ERR_OK)
    {
        // Restore enchantments
        if (pDstItem)
        {
            _player->ApplyEnchantment(pDstItem, true);
        }

        _player->SendEquipError(msg, pSrcItem, nullptr);
        return;
    }

    if (!pDstItem)                                         // empty slot, simple case
    {
        _player->RemoveItem(srcbag, srcslot, true);
        _player->EquipItem(dest, pSrcItem, true);
        _player->AutoUnequipOffhandIfNeed();
    }
    else                                                    // have currently equipped item, not simple case
    {
        // Restore enchantments
        _player->ApplyEnchantment(pDstItem, true);

        uint8 dstbag = pDstItem->GetBagSlot();
        uint8 dstslot = pDstItem->GetSlot();

        msg = _player->CanUnequipItem(dest, !pSrcItem->IsBag());
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pDstItem, nullptr);
            return;
        }

        // check dest->src move possibility
        ItemPosCountVec sSrc;
        uint16 eSrc = 0;
        if (_player->IsInventoryPos(src))
        {
            msg = _player->CanStoreItem(srcbag, srcslot, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanStoreItem(srcbag, NULL_SLOT, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, pDstItem, true);
        }
        else if (_player->IsBankPos(src))
        {
            msg = _player->CanBankItem(srcbag, srcslot, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanBankItem(srcbag, NULL_SLOT, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanBankItem(NULL_BAG, NULL_SLOT, sSrc, pDstItem, true);
        }
        else if (_player->IsEquipmentPos(src))
        {
            msg = _player->CanEquipItem(srcslot, eSrc, pDstItem, true);
            if (msg == EQUIP_ERR_OK)
                msg = _player->CanUnequipItem(eSrc, true);
        }

        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pDstItem, pSrcItem);
            return;
        }

        // now do moves, remove...
        _player->RemoveItem(dstbag, dstslot, true, true);
        _player->RemoveItem(srcbag, srcslot, true, true);

        // add to dest
        _player->EquipItem(dest, pSrcItem, true);

        // add to src
        if (_player->IsInventoryPos(src))
            _player->StoreItem(sSrc, pDstItem, true);
        else if (_player->IsBankPos(src))
            _player->BankItem(sSrc, pDstItem, true);
        else if (_player->IsEquipmentPos(src))
            _player->EquipItem(eSrc, pDstItem, true);

        _player->AutoUnequipOffhandIfNeed();

        // Xinef: Call this here after all needed items are equipped
        _player->RemoveItemDependentAurasAndCasts((Item*)nullptr);
    }
}

void WorldSession::HandleDestroyItemOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_DESTROYITEM");
    uint8 bag, slot, count, data1, data2, data3;

    recvData >> bag >> slot >> count >> data1 >> data2 >> data3;

    uint16 pos = (bag << 8) | slot;

    // prevent drop unequipable items (in combat, for example) and non-empty bags
    if (_player->IsEquipmentPos(pos) || _player->IsBagPos(pos))
    {
        InventoryResult msg = _player->CanUnequipItem(pos, false);
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, _player->GetItemByPos(pos), nullptr);
            return;
        }
    }

    Item* pItem  = _player->GetItemByPos(bag, slot);
    if (!pItem)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
        return;
    }

    if (pItem->GetTemplate()->Flags & ITEM_FLAG_NO_USER_DESTROY)
    {
        _player->SendEquipError(EQUIP_ERR_CANT_DROP_SOULBOUND, nullptr, nullptr);
        return;
    }

    recoveryItem(pItem);

    if (count)
    {
        uint32 i_count = count;
        _player->DestroyItemCount(pItem, i_count, true);
    }
    else
    {
        _player->DestroyItem(bag, slot, true);
    }
    _player->SendQuestGiverStatusMultiple();
}

bool ItemTemplate::HasStat(ItemModType stat) const
{
    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
    {
        if (i >= StatsCount)
        {
            break;
        }

        if (ItemStat[i].ItemStatType == stat)
        {
            return true;
        }
    }

    return false;
}

bool ItemTemplate::HasSpellPowerStat() const
{
    bool invalid = false;
    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = Spells[i];
        if (!spellData.SpellId)
        {
            continue;
        }

        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
        if (!spellInfo)
        {
            continue;
        }

        for (uint8 j = EFFECT_0; j <= EFFECT_2; ++j)
        {
            switch (spellInfo->Effects[j].ApplyAuraName)
            {
                case SPELL_AURA_MOD_HEALING_DONE:
                case SPELL_AURA_MOD_SPELL_HEALING_OF_STAT_PERCENT:
                case SPELL_AURA_MOD_SPELL_HEALING_OF_ATTACK_POWER:
                case SPELL_AURA_MOD_HEALING:
                    invalid = true;
                    break;
                case SPELL_AURA_MOD_DAMAGE_DONE:
                case SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT:
                case SPELL_AURA_MOD_SPELL_DAMAGE_OF_ATTACK_POWER:
                case SPELL_AURA_MOD_DAMAGE_TAKEN:
                    if (!(spellInfo->Effects[j].MiscValue & SPELL_SCHOOL_MASK_SPELL))
                    {
                        return false;
                    }
                    invalid = true;
                    break;
                default:
                    break;
            }
        }
    }

    return invalid;
}

void ItemTemplate::InitializeQueryData()
{
    queryData.Initialize(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 1);

    queryData << ItemId;
    queryData << Class;
    queryData << SubClass;
    queryData << SoundOverrideSubclass;
    queryData << Name1;
    queryData << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
    queryData << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
    queryData << uint8(0x00);                                //pProto->Name4; // blizz not send name there, just uint8(0x00);
    queryData << DisplayInfoID;
    queryData << Quality;
    queryData << Flags;
    queryData << Flags2;
    queryData << BuyPrice;
    queryData << SellPrice;
    queryData << InventoryType;
    queryData << AllowableClass;
    queryData << AllowableRace;
    queryData << ItemLevel;
    queryData << RequiredLevel;
    queryData << RequiredSkill;
    queryData << RequiredSkillRank;
    queryData << RequiredSpell;
    queryData << RequiredHonorRank;
    queryData << RequiredCityRank;
    queryData << RequiredReputationFaction;
    queryData << RequiredReputationRank;
    queryData << int32(MaxCount);
    queryData << int32(Stackable);
    queryData << ContainerSlots;
    queryData << StatsCount;                         // item stats count
    for (uint32 i = 0; i < StatsCount; ++i)
    {
        queryData << ItemStat[i].ItemStatType;
        queryData << ItemStat[i].ItemStatValue;
    }
    queryData << ScalingStatDistribution;            // scaling stats distribution
    queryData << ScalingStatValue;                   // some kind of flags used to determine stat values column
    for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
    {
        queryData << Damage[i].DamageMin;
        queryData << Damage[i].DamageMax;
        queryData << Damage[i].DamageType;
    }

    // resistances (7)
    queryData << Armor;
    queryData << HolyRes;
    queryData << FireRes;
    queryData << NatureRes;
    queryData << FrostRes;
    queryData << ShadowRes;
    queryData << ArcaneRes;

    queryData << Delay;
    queryData << AmmoType;
    queryData << RangedModRange;

    for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
    {
        // send DBC data for cooldowns in same way as it used in Spell::SendSpellCooldown
        // use `item_template` or if not set then only use spell cooldowns
        SpellInfo const* spell = sSpellMgr->GetSpellInfo(Spells[s].SpellId);
        if (spell)
        {
            bool db_data = Spells[s].SpellCooldown >= 0 || Spells[s].SpellCategoryCooldown >= 0;

            queryData << Spells[s].SpellId;
            queryData << Spells[s].SpellTrigger;
            queryData << int32(Spells[s].SpellCharges);

            if (db_data)
            {
                queryData << uint32(Spells[s].SpellCooldown);
                queryData << uint32(Spells[s].SpellCategory);
                queryData << uint32(Spells[s].SpellCategoryCooldown);
            }
            else
            {
                queryData << uint32(spell->RecoveryTime);
                queryData << uint32(spell->GetCategory());
                queryData << uint32(spell->CategoryRecoveryTime);
            }
        }
        else
        {
            queryData << uint32(0);
            queryData << uint32(0);
            queryData << uint32(0);
            queryData << uint32(-1);
            queryData << uint32(0);
            queryData << uint32(-1);
        }
    }
    queryData << Bonding;
    queryData << Description;
    queryData << PageText;
    queryData << LanguageID;
    queryData << PageMaterial;
    queryData << StartQuest;
    queryData << LockID;
    queryData << int32(Material);
    queryData << Sheath;
    queryData << RandomProperty;
    queryData << RandomSuffix;
    queryData << Block;
    queryData << ItemSet;
    queryData << MaxDurability;
    queryData << Area;
    queryData << Map;                                // Added in 1.12.x & 2.0.1 client branch
    queryData << BagFamily;
    queryData << TotemCategory;
    for (int s = 0; s < MAX_ITEM_PROTO_SOCKETS; ++s)
    {
        queryData << Socket[s].Color;
        queryData << Socket[s].Content;
    }
    queryData << socketBonus;
    queryData << GemProperties;
    queryData << RequiredDisenchantSkill;
    queryData << ArmorDamageModifier;
    queryData << Duration;                           // added in 2.4.2.8209, duration (seconds)
    queryData << ItemLimitCategory;                  // WotLK, ItemLimitCategory
    queryData << HolidayId;                          // Holiday.dbc?
}

// Only _static_ data send in this packet !!!
void WorldSession::HandleItemQuerySingleOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_ITEM_QUERY_SINGLE");
    uint32 item;
    recvData >> item;

    LOG_DEBUG("network.opcode", "STORAGE: Item Query = {}", item);

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (pProto)
    {
        std::string Name = pProto->Name1;
        std::string Description = pProto->Description;

        int loc_idx = GetSessionDbLocaleIndex();
        if (loc_idx >= 0)
        {
            if (ItemLocale const* il = sObjectMgr->GetItemLocale(pProto->ItemId))
            {
                ObjectMgr::GetLocaleString(il->Name, loc_idx, Name);
                ObjectMgr::GetLocaleString(il->Description, loc_idx, Description);
            }
        }
        // guess size
        WorldPacket queryData(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 600);
        queryData << pProto->ItemId;
        queryData << pProto->Class;
        queryData << pProto->SubClass;
        queryData << pProto->SoundOverrideSubclass;
        queryData << Name;
        queryData << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
        queryData << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
        queryData << uint8(0x00);                                //pProto->Name4; // blizz not send name there, just uint8(0x00);
        queryData << pProto->DisplayInfoID;
        queryData << pProto->Quality;
        queryData << pProto->Flags;
        queryData << pProto->Flags2;
        queryData << pProto->BuyPrice;
        queryData << pProto->SellPrice;
        queryData << pProto->InventoryType;
        queryData << pProto->AllowableClass;
        queryData << pProto->AllowableRace;
        queryData << pProto->ItemLevel;
        queryData << pProto->RequiredLevel;
        queryData << pProto->RequiredSkill;
        queryData << pProto->RequiredSkillRank;
        queryData << pProto->RequiredSpell;
        queryData << pProto->RequiredHonorRank;
        queryData << pProto->RequiredCityRank;
        queryData << pProto->RequiredReputationFaction;
        queryData << pProto->RequiredReputationRank;
        queryData << int32(pProto->MaxCount);
        queryData << int32(pProto->Stackable);
        queryData << pProto->ContainerSlots;
        queryData << pProto->StatsCount;                         // item stats count
        for (uint32 i = 0; i < pProto->StatsCount; ++i)
        {
            queryData << pProto->ItemStat[i].ItemStatType;
            queryData << pProto->ItemStat[i].ItemStatValue;
        }
        queryData << pProto->ScalingStatDistribution;            // scaling stats distribution
        queryData << pProto->ScalingStatValue;                   // some kind of flags used to determine stat values column
        for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
        {
            queryData << pProto->Damage[i].DamageMin;
            queryData << pProto->Damage[i].DamageMax;
            queryData << pProto->Damage[i].DamageType;
        }

        // resistances (7)
        queryData << pProto->Armor;
        queryData << pProto->HolyRes;
        queryData << pProto->FireRes;
        queryData << pProto->NatureRes;
        queryData << pProto->FrostRes;
        queryData << pProto->ShadowRes;
        queryData << pProto->ArcaneRes;

        queryData << pProto->Delay;
        queryData << pProto->AmmoType;
        queryData << pProto->RangedModRange;

        for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
        {
            // send DBC data for cooldowns in same way as it used in Spell::SendSpellCooldown
            // use `item_template` or if not set then only use spell cooldowns
            SpellInfo const* spell = sSpellMgr->GetSpellInfo(pProto->Spells[s].SpellId);
            if (spell)
            {
                bool db_data = pProto->Spells[s].SpellCooldown >= 0 || pProto->Spells[s].SpellCategoryCooldown >= 0;

                queryData << pProto->Spells[s].SpellId;
                queryData << pProto->Spells[s].SpellTrigger;
                queryData << int32(pProto->Spells[s].SpellCharges);

                if (db_data)
                {
                    queryData << uint32(pProto->Spells[s].SpellCooldown);
                    queryData << uint32(pProto->Spells[s].SpellCategory);
                    queryData << uint32(pProto->Spells[s].SpellCategoryCooldown);
                }
                else
                {
                    queryData << uint32(spell->RecoveryTime);
                    queryData << uint32(spell->GetCategory());
                    queryData << uint32(spell->CategoryRecoveryTime);
                }
            }
            else
            {
                queryData << uint32(0);
                queryData << uint32(0);
                queryData << uint32(0);
                queryData << uint32(-1);
                queryData << uint32(0);
                queryData << uint32(-1);
            }
        }
        queryData << pProto->Bonding;
        queryData << Description;
        queryData << pProto->PageText;
        queryData << pProto->LanguageID;
        queryData << pProto->PageMaterial;
        queryData << pProto->StartQuest;
        queryData << pProto->LockID;
        queryData << int32(pProto->Material);
        queryData << pProto->Sheath;
        queryData << pProto->RandomProperty;
        queryData << pProto->RandomSuffix;
        queryData << pProto->Block;
        queryData << pProto->ItemSet;
        queryData << pProto->MaxDurability;
        queryData << pProto->Area;
        queryData << pProto->Map;                                // Added in 1.12.x & 2.0.1 client branch
        queryData << pProto->BagFamily;
        queryData << pProto->TotemCategory;
        for (int s = 0; s < MAX_ITEM_PROTO_SOCKETS; ++s)
        {
            queryData << pProto->Socket[s].Color;
            queryData << pProto->Socket[s].Content;
        }
        queryData << pProto->socketBonus;
        queryData << pProto->GemProperties;
        queryData << pProto->RequiredDisenchantSkill;
        queryData << pProto->ArmorDamageModifier;
        queryData << pProto->Duration;                           // added in 2.4.2.8209, duration (seconds)
        queryData << pProto->ItemLimitCategory;                  // WotLK, ItemLimitCategory
        queryData << pProto->HolidayId;                          // Holiday.dbc?
        SendPacket(&queryData);
    }
    else
    {
        LOG_DEBUG("network", "WORLD: CMSG_ITEM_QUERY_SINGLE - NO item INFO! (ENTRY: {})", item);
        WorldPacket queryData(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 4);
        queryData << uint32(item | 0x80000000);
        SendPacket(&queryData);
    }
}

void WorldSession::HandleReadItem(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_READ_ITEM");

    uint8 bag, slot;
    recvData >> bag >> slot;

    //LOG_DEBUG("network.opcode", "STORAGE: Read bag = {}, slot = {}", bag, slot);
    Item* pItem = _player->GetItemByPos(bag, slot);

    if (pItem && pItem->GetTemplate()->PageText)
    {
        WorldPacket data;

        InventoryResult msg = _player->CanUseItem(pItem);
        if (msg == EQUIP_ERR_OK)
        {
            data.Initialize (SMSG_READ_ITEM_OK, 8);
            LOG_DEBUG("network.opcode", "STORAGE: Item page sent");
        }
        else
        {
            data.Initialize(SMSG_READ_ITEM_FAILED, 8);
            LOG_DEBUG("network.opcode", "STORAGE: Unable to read item");
            _player->SendEquipError(msg, pItem, nullptr);
        }
        data << pItem->GetGUID();
        SendPacket(&data);
    }
    else
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
}

void WorldSession::HandleSellItemOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: Received CMSG_SELL_ITEM");
    ObjectGuid vendorguid, itemguid;
    uint32 count;

    recvData >> vendorguid >> itemguid >> count;

    if (!itemguid)
        return;

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        LOG_DEBUG("network", "WORLD: HandleSellItemOpcode - Unit ({}) not found or you can not interact with him.", vendorguid.ToString());
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, nullptr, itemguid, 0);
        return;
    }

    if ((creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_SELL_VENDOR) != 0)
    {
        _player->SendSellError(SELL_ERR_CANT_SELL_TO_THIS_MERCHANT, creature, itemguid, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = _player->GetItemByGuid(itemguid);
    if (pItem)
    {
        if (!sScriptMgr->CanSellItem(_player, pItem, creature))
            return;

        // prevent sell not owner item
        if (_player->GetGUID() != pItem->GetOwnerGUID())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
            return;
        }

        // prevent sell non empty bag by drag-and-drop at vendor's item list
        if (pItem->IsNotEmptyBag())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
            return;
        }

        // prevent sell currently looted item
        if (_player->GetLootGUID() == pItem->GetGUID())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
            return;
        }

        // prevent selling item for sellprice when the item is still refundable
        // this probably happens when right clicking a refundable item, the client sends both
        // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
        if (pItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_REFUNDABLE))
            return; // Therefore, no feedback to client

        // special case at auto sell (sell all)
        if (count == 0)
        {
            count = pItem->GetCount();
        }
        else
        {
            // prevent sell more items that exist in stack (possible only not from client)
            if (count > pItem->GetCount())
            {
                _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
                return;
            }
        }

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            if (pProto->SellPrice > 0)
            {
                uint32 money = pProto->SellPrice * count;
                if (_player->GetMoney() >= MAX_MONEY_AMOUNT - money)               // prevent exceeding gold limit
                {
                    _player->SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD, nullptr, nullptr);
                    _player->SendSellError(SELL_ERR_UNK, creature, itemguid, 0);
                    return;
                }

                if (sWorld->getBoolConfig(CONFIG_ITEMDELETE_VENDOR))
                    recoveryItem(pItem);

                uint32 maxDurability = pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
                if (maxDurability)
                {
                    uint32 curDurability = pItem->GetUInt32Value(ITEM_FIELD_DURABILITY);
                    uint32 LostDurability = maxDurability - curDurability;

                    if (LostDurability > 0)
                    {
                        DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(pProto->ItemLevel);
                        if (!dcost)
                        {
                            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
                            LOG_ERROR("network.opcode", "WORLD: HandleSellItemOpcode - Wrong item lvl {} for item {} count = {}", pProto->ItemLevel, pItem->GetEntry(), count);
                            return;
                        }

                        uint32 dQualitymodEntryId = (pProto->Quality + 1) * 2;
                        DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
                        if (!dQualitymodEntry)
                        {
                            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
                            LOG_ERROR("network.opcode", "WORLD: HandleSellItemOpcode - Wrong dQualityModEntry {} for item {} count = {}", dQualitymodEntryId, pItem->GetEntry(), count);
                            return;
                        }

                        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(pProto->Class, pProto->SubClass)];
                        uint32 refund = uint32(std::ceil(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod)));

                        if (!refund)
                        {
                            refund = 1;
                        }

                        //starter items can cost more to refund than vendorprice
                        if (refund > money)
                        {
                            money = 1;
                        }
                        else
                        {
                            money -= refund;
                        }
                    }
                }

                if (count < pItem->GetCount())               // need split items
                {
                    Item* pNewItem = pItem->CloneItem(count, _player);
                    if (!pNewItem)
                    {
                        LOG_ERROR("network.opcode", "WORLD: HandleSellItemOpcode - could not create clone of item {}; count = {}", pItem->GetEntry(), count);
                        _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
                        return;
                    }

                    pNewItem->SetUInt32Value(ITEM_FIELD_DURABILITY, pItem->GetUInt32Value(ITEM_FIELD_DURABILITY));

                    pItem->SetCount(pItem->GetCount() - count);
                    _player->ItemRemovedQuestCheck(pItem->GetEntry(), count);
                    if (_player->IsInWorld())
                        pItem->SendUpdateToPlayer(_player);
                    pItem->SetState(ITEM_CHANGED, _player);

                    _player->AddItemToBuyBackSlot(pNewItem, money);
                    if (_player->IsInWorld())
                        pNewItem->SendUpdateToPlayer(_player);
                }
                else
                {
                    _player->ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
                    _player->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
                    pItem->RemoveFromUpdateQueueOf(_player);
                    _player->AddItemToBuyBackSlot(pItem, money);
                    _player->UpdateTitansGrip();
                }

                _player->ModifyMoney(money);
                _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_VENDORS, money);
            }
            else
                _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemguid, 0);
            return;
        }
    }
    _player->SendSellError(SELL_ERR_CANT_FIND_ITEM, creature, itemguid, 0);
    return;
}

void WorldSession::HandleBuybackItem(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: Received CMSG_BUYBACK_ITEM");
    ObjectGuid vendorguid;
    uint32 slot;

    recvData >> vendorguid >> slot;

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        LOG_DEBUG("network", "WORLD: HandleBuybackItem - Unit ({}) not found or you can not interact with him.", vendorguid.ToString());
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, nullptr, ObjectGuid::Empty, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = _player->GetItemFromBuyBackSlot(slot);
    if (pItem)
    {
        uint32 price = _player->GetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE_1 + slot - BUYBACK_SLOT_START);
        if (!_player->HasEnoughMoney(price))
        {
            _player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, pItem->GetEntry(), 0);
            return;
        }

        ItemPosCountVec dest;
        InventoryResult msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg == EQUIP_ERR_OK)
        {
            if (sWorld->getBoolConfig(CONFIG_ITEMDELETE_VENDOR))
            {
                CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_RECOVERY_ITEM);
                stmt->SetData(0, _player->GetGUID().GetCounter());
                stmt->SetData(1, pItem->GetEntry());
                stmt->SetData(2, pItem->GetCount());
                CharacterDatabase.Execute(stmt);
            }

            _player->ModifyMoney(-(int32)price);
            _player->RemoveItemFromBuyBackSlot(slot, false);
            _player->ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
            _player->StoreItem(dest, pItem, true);
        }
        else
            _player->SendEquipError(msg, pItem, nullptr);
        return;
    }
    else
        _player->SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, 0, 0);
}

void WorldSession::HandleBuyItemInSlotOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: Received CMSG_BUY_ITEM_IN_SLOT");
    ObjectGuid vendorguid, bagguid;
    uint32 item, slot, count;
    uint8 bagslot;

    recvData >> vendorguid >> item  >> slot >> bagguid >> bagslot >> count;

    // client expects count starting at 1, and we send vendorslot+1 to client already
    if (slot > 0)
        --slot;
    else
        return;                                             // cheating

    uint8 bag = NULL_BAG;                                   // init for case invalid bagGUID

    // find bag slot by bag guid
    if (bagguid == _player->GetGUID())
        bag = INVENTORY_SLOT_BAG_0;
    else
    {
        for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Bag* pBag = _player->GetBagByPos(i))
            {
                if (bagguid == pBag->GetGUID())
                {
                    bag = i;
                    break;
                }
            }
        }
    }

    // bag not found, cheating?
    if (bag == NULL_BAG)
        return;

    GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, bag, bagslot);
}

void WorldSession::HandleBuyItemOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: Received CMSG_BUY_ITEM");
    ObjectGuid vendorguid;
    uint32 item, slot, count;
    uint8 unk1;

    recvData >> vendorguid >> item >> slot >> count >> unk1;

    // client expects count starting at 1, and we send vendorslot+1 to client already
    if (slot > 0)
        --slot;
    else
        return; // cheating

    GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, NULL_BAG, NULL_SLOT);
}

void WorldSession::HandleListInventoryOpcode(WorldPacket& recvData)
{
    ObjectGuid guid;

    recvData >> guid;

    if (!GetPlayer()->IsAlive())
        return;

    LOG_DEBUG("network", "WORLD: Recvd CMSG_LIST_INVENTORY");

    SendListInventory(guid);
}

void WorldSession::SendListInventory(ObjectGuid vendorGuid, uint32 vendorEntry)
{
    LOG_DEBUG("network", "WORLD: Sent SMSG_LIST_INVENTORY");

    Creature* vendor = GetPlayer()->GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!vendor)
    {
        LOG_DEBUG("network", "WORLD: SendListInventory - Unit ({}) not found or you can not interact with him.", vendorGuid.ToString());
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, nullptr, ObjectGuid::Empty, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
    {
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);
    }

    // Stop the npc if moving
    if (uint32 pause = vendor->GetMovementTemplate().GetInteractionPauseTimer())
        vendor->PauseMovement(pause);
    vendor->SetHomePosition(vendor->GetPosition());

    SetCurrentVendor(vendorEntry);

    VendorItemData const* items = vendorEntry ? sObjectMgr->GetNpcVendorItemList(vendorEntry) : vendor->GetVendorItems();
    if (!items)
    {
        WorldPacket data(SMSG_LIST_INVENTORY, 8 + 1 + 1);
        data << vendorGuid;
        data << uint8(0);                                   // count == 0, next will be error code
        data << uint8(0);                                   // "Vendor has no inventory"
        SendPacket(&data);
        return;
    }

    uint8 itemCount = items->GetItemCount();
    uint8 count = 0;

    WorldPacket data(SMSG_LIST_INVENTORY, 8 + 1 + itemCount * 8 * 4);
    data << vendorGuid;

    size_t countPos = data.wpos();
    data << uint8(count);

    float discountMod = _player->GetReputationPriceDiscount(vendor);

    for (uint8 slot = 0; slot < itemCount; ++slot)
    {
        if (VendorItem const* item = items->GetItem(slot))
        {
            if (ItemTemplate const* itemTemplate = sObjectMgr->GetItemTemplate(item->item))
            {
                if (!(itemTemplate->AllowableClass & _player->getClassMask()) && itemTemplate->Bonding == BIND_WHEN_PICKED_UP && !_player->IsGameMaster())
                {
                    continue;
                }
                // Only display items in vendor lists for the team the
                // player is on. If GM on, display all items.
                if (!_player->IsGameMaster() && ((itemTemplate->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && _player->GetTeamId() == TEAM_ALLIANCE) || (itemTemplate->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && _player->GetTeamId() == TEAM_HORDE)))
                {
                    continue;
                }

                // Items sold out are not displayed in list
                uint32 leftInStock = !item->maxcount ? 0xFFFFFFFF : vendor->GetVendorItemCurrentCount(item);
                if (!_player->IsGameMaster() && !leftInStock)
                {
                    continue;
                }

                ConditionList conditions = sConditionMgr->GetConditionsForNpcVendorEvent(vendor->GetEntry(), item->item);
                if (!sConditionMgr->IsObjectMeetToConditions(_player, vendor, conditions))
                {
                    LOG_DEBUG("network", "SendListInventory: conditions not met for creature entry {} item {}", vendor->GetEntry(), item->item);
                    continue;
                }

                // reputation discount
                int32 price = item->IsGoldRequired(itemTemplate) ? uint32(floor(itemTemplate->BuyPrice * discountMod)) : 0;

                data << uint32(slot + 1);       // client expects counting to start at 1
                data << uint32(item->item);
                data << uint32(itemTemplate->DisplayInfoID);
                data << int32(leftInStock);
                data << uint32(price);
                data << uint32(itemTemplate->MaxDurability);
                data << uint32(itemTemplate->BuyCount);
                data << uint32(item->ExtendedCost);

                if (++count >= MAX_VENDOR_ITEMS)
                {
                    break;
                }
            }
        }
    }

    if (count == 0)
    {
        data << uint8(0);
        SendPacket(&data);
        return;
    }

    data.put<uint8>(countPos, count);
    SendPacket(&data);
}

void WorldSession::HandleAutoStoreBagItemOpcode(WorldPacket& recvData)
{
    //LOG_DEBUG("network.opcode", "WORLD: CMSG_AUTOSTORE_BAG_ITEM");
    uint8 srcbag, srcslot, dstbag;

    recvData >> srcbag >> srcslot >> dstbag;

    Item* pItem = _player->GetItemByPos(srcbag, srcslot);
    if (!pItem)
        return;

    if (!_player->IsValidPos(dstbag, NULL_SLOT, false))      // can be autostore pos
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_DOESNT_GO_TO_SLOT, nullptr, nullptr);
        return;
    }

    uint16 src = pItem->GetPos();

    // check unequip potability for equipped items and bank bags
    if (_player->IsEquipmentPos (src) || _player->IsBagPos (src))
    {
        InventoryResult msg = _player->CanUnequipItem(src, !_player->IsBagPos (src));
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pItem, nullptr);
            return;
        }
    }

    ItemPosCountVec dest;
    InventoryResult msg = _player->CanStoreItem(dstbag, NULL_SLOT, dest, pItem, false);
    if (msg != EQUIP_ERR_OK)
    {
        _player->SendEquipError(msg, pItem, nullptr);
        return;
    }

    // no-op: placed in same slot
    if (dest.size() == 1 && dest[0].pos == src)
    {
        // just remove grey item state
        _player->SendEquipError(EQUIP_ERR_NONE, pItem, nullptr);
        return;
    }

    _player->RemoveItem(srcbag, srcslot, true);
    _player->StoreItem(dest, pItem, true);
    _player->UpdateTitansGrip();
}

void WorldSession::HandleSetAmmoOpcode(WorldPacket& recvData)
{
    if (!_player->IsAlive())
    {
        _player->SendEquipError(EQUIP_ERR_YOU_ARE_DEAD, nullptr, nullptr);
        return;
    }

    LOG_DEBUG("network", "WORLD: CMSG_SET_AMMO");
    uint32 item;

    recvData >> item;

    if (item)
    {
        if (!_player->GetItemCount(item))
        {
            _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
            return;
        }

        _player->SetAmmo(item);
    }
    else
        _player->RemoveAmmo();
}

void WorldSession::SendEnchantmentLog(ObjectGuid target, ObjectGuid caster, uint32 itemId, uint32 enchantId)
{
    WorldPacket data(SMSG_ENCHANTMENTLOG, (8 + 8 + 4 + 4)); // last check 2.0.10
    data << target.WriteAsPacked();
    data << caster.WriteAsPacked();
    data << uint32(itemId);
    data << uint32(enchantId);
    GetPlayer()->SendMessageToSet(&data, true);
}

void WorldSession::SendItemEnchantTimeUpdate(ObjectGuid Playerguid, ObjectGuid Itemguid, uint32 slot, uint32 Duration)
{
    // last check 2.0.10
    WorldPacket data(SMSG_ITEM_ENCHANT_TIME_UPDATE, (8 + 4 + 4 + 8));
    data << Itemguid;
    data << uint32(slot);
    data << uint32(Duration);
    data << Playerguid;
    SendPacket(&data);
}

void WorldSession::HandleItemNameQueryOpcode(WorldPacket& recvData)
{
    uint32 itemid;
    recvData >> itemid;
    recvData.read_skip<uint64>();                          // guid

    LOG_DEBUG("network", "WORLD: CMSG_ITEM_NAME_QUERY {}", itemid);
    ItemSetNameEntry const* pName = sObjectMgr->GetItemSetNameEntry(itemid);
    if (pName)
    {
        std::string Name = pName->name;
        LocaleConstant loc_idx = GetSessionDbLocaleIndex();
        if (loc_idx >= 0)
            if (ItemSetNameLocale const* isnl = sObjectMgr->GetItemSetNameLocale(itemid))
                ObjectMgr::GetLocaleString(isnl->Name, loc_idx, Name);

        WorldPacket data(SMSG_ITEM_NAME_QUERY_RESPONSE, (4 + Name.size() + 1 + 4));
        data << uint32(itemid);
        data << Name;
        data << uint32(pName->InventoryType);
        SendPacket(&data);
    }
}

void WorldSession::HandleWrapItemOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "Received opcode CMSG_WRAP_ITEM");

    uint8 gift_bag, gift_slot, item_bag, item_slot;

    recvData >> gift_bag >> gift_slot;                     // paper
    recvData >> item_bag >> item_slot;                     // item

    LOG_DEBUG("network", "WRAP: receive gift_bag = {}, gift_slot = {}, item_bag = {}, item_slot = {}", gift_bag, gift_slot, item_bag, item_slot);

    Item* gift = _player->GetItemByPos(gift_bag, gift_slot);
    if (!gift)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, nullptr);
        return;
    }

    if (!(gift->GetTemplate()->Flags & ITEM_FLAG_IS_WRAPPER)) // cheating: non-wrapper wrapper
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, nullptr);
        return;
    }

    Item* item = _player->GetItemByPos(item_bag, item_slot);

    if (!item)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, item, nullptr);
        return;
    }

    // xinef: do not allow to wrap removed items, just in case
    if (item->GetState() == ITEM_REMOVED)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, item, nullptr);
        return;
    }

    if (item == gift)                                          // not possable with pacjket from real client
    {
        _player->SendEquipError(EQUIP_ERR_WRAPPED_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    if (item->IsEquipped())
    {
        _player->SendEquipError(EQUIP_ERR_EQUIPPED_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    if (item->GetGuidValue(ITEM_FIELD_GIFTCREATOR))        // HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAGS_WRAPPED);
    {
        _player->SendEquipError(EQUIP_ERR_WRAPPED_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    if (item->IsBag())
    {
        _player->SendEquipError(EQUIP_ERR_BAGS_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    if (item->IsSoulBound())
    {
        _player->SendEquipError(EQUIP_ERR_BOUND_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    if (item->GetMaxStackCount() != 1)
    {
        _player->SendEquipError(EQUIP_ERR_STACKABLE_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    // maybe not correct check  (it is better than nothing)
    if (item->GetTemplate()->MaxCount > 0)
    {
        _player->SendEquipError(EQUIP_ERR_UNIQUE_CANT_BE_WRAPPED, item, nullptr);
        return;
    }

    CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();

    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GIFT);
    stmt->SetData(0, item->GetOwnerGUID().GetCounter());
    stmt->SetData(1, item->GetGUID().GetCounter());
    stmt->SetData(2, item->GetEntry());
    stmt->SetData(3, item->GetUInt32Value(ITEM_FIELD_FLAGS));
    trans->Append(stmt);

    item->SetEntry(gift->GetEntry());

    switch (item->GetEntry())
    {
        case 5042:
            item->SetEntry(5043);
            break;
        case 5048:
            item->SetEntry(5044);
            break;
        case 17303:
            item->SetEntry(17302);
            break;
        case 17304:
            item->SetEntry(17305);
            break;
        case 17307:
            item->SetEntry(17308);
            break;
        case 21830:
            item->SetEntry(21831);
            break;
    }
    item->SetGuidValue(ITEM_FIELD_GIFTCREATOR, _player->GetGUID());
    item->SetUInt32Value(ITEM_FIELD_FLAGS, ITEM_FIELD_FLAG_WRAPPED);
    item->SetState(ITEM_CHANGED, _player);

    // after save it will be impossible to remove the item from the queue
    _player->SaveInventoryAndGoldToDB(trans);

    CharacterDatabase.CommitTransaction(trans);

    uint32 count = 1;
    _player->DestroyItemCount(gift, count, true);
}

void WorldSession::HandleSocketOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: CMSG_SOCKET_GEMS");

    ObjectGuid item_guid;
    ObjectGuid gem_guids[MAX_GEM_SOCKETS];

    recvData >> item_guid;
    if (!item_guid)
        return;

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData >> gem_guids[i];

    //cheat -> tried to socket same gem multiple times
    if ((gem_guids[0] && (gem_guids[0] == gem_guids[1] || gem_guids[0] == gem_guids[2])) ||
            (gem_guids[1] && (gem_guids[1] == gem_guids[2])))
        return;

    Item* itemTarget = _player->GetItemByGuid(item_guid);
    if (!itemTarget)                                         //missing item to socket
        return;

    ItemTemplate const* itemProto = itemTarget->GetTemplate();
    if (!itemProto)
        return;

    //this slot is excepted when applying / removing meta gem bonus
    uint8 slot = itemTarget->IsEquipped() ? itemTarget->GetSlot() : uint8(NULL_SLOT);

    Item* Gems[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        Gems[i] = gem_guids[i] ? _player->GetItemByGuid(gem_guids[i]) : nullptr;

    GemPropertiesEntry const* GemProps[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //get geminfo from dbc storage
        GemProps[i] = (Gems[i]) ? sGemPropertiesStore.LookupEntry(Gems[i]->GetTemplate()->GemProperties) : nullptr;

    // Find first prismatic socket
    int32 firstPrismatic = 0;
    while (firstPrismatic < MAX_GEM_SOCKETS && itemProto->Socket[firstPrismatic].Color)
        ++firstPrismatic;

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //check for hack maybe
    {
        if (!GemProps[i])
            continue;

        // tried to put gem in socket where no socket exists (take care about prismatic sockets)
        if (!itemProto->Socket[i].Color)
        {
            // no prismatic socket
            if (!itemTarget->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
                return;

            if (i != firstPrismatic)
                return;
        }

        // tried to put normal gem in meta socket
        if (itemProto->Socket[i].Color == SOCKET_COLOR_META && GemProps[i]->color != SOCKET_COLOR_META)
            return;

        // tried to put meta gem in normal socket
        if (itemProto->Socket[i].Color != SOCKET_COLOR_META && GemProps[i]->color == SOCKET_COLOR_META)
            return;
    }

    uint32 GemEnchants[MAX_GEM_SOCKETS];
    uint32 OldEnchants[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //get new and old enchantments
    {
        GemEnchants[i] = (GemProps[i]) ? GemProps[i]->spellitemenchantement : 0;
        OldEnchants[i] = itemTarget->GetEnchantmentId(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT + i));
    }

    // check unique-equipped conditions
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!Gems[i])
            continue;

        // continue check for case when attempt add 2 similar unique equipped gems in one item.
        ItemTemplate const* iGemProto = Gems[i]->GetTemplate();

        // unique item (for new and already placed bit removed enchantments
        if (iGemProto->Flags & ITEM_FLAG_UNIQUE_EQUIPPABLE)
        {
            for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
            {
                if (i == j)                                    // skip self
                    continue;

                if (Gems[j])
                {
                    if (iGemProto->ItemId == Gems[j]->GetEntry())
                    {
                        _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, nullptr);
                        return;
                    }
                }
                else if (OldEnchants[j])
                {
                    if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                    {
                        if (iGemProto->ItemId == enchantEntry->GemID)
                        {
                            _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, nullptr);
                            return;
                        }
                    }
                }
            }
        }

        // unique limit type item
        int32 limit_newcount = 0;
        if (iGemProto->ItemLimitCategory)
        {
            if (ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(iGemProto->ItemLimitCategory))
            {
                // NOTE: limitEntry->mode is not checked because if item has limit then it is applied in equip case
                for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
                {
                    if (Gems[j])
                    {
                        // new gem
                        if (iGemProto->ItemLimitCategory == Gems[j]->GetTemplate()->ItemLimitCategory)
                            ++limit_newcount;
                    }
                    else if (OldEnchants[j])
                    {
                        // existing gem
                        if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                            if (ItemTemplate const* jProto = sObjectMgr->GetItemTemplate(enchantEntry->GemID))
                                if (iGemProto->ItemLimitCategory == jProto->ItemLimitCategory)
                                    ++limit_newcount;
                    }
                }

                if (limit_newcount > 0 && uint32(limit_newcount) > limitEntry->maxCount)
                {
                    _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, nullptr);
                    return;
                }
            }
        }

        // for equipped item check all equipment for duplicate equipped gems
        if (itemTarget->IsEquipped())
        {
            if (InventoryResult res = _player->CanEquipUniqueItem(Gems[i], slot, std::max(limit_newcount, 0)))
            {
                _player->SendEquipError(res, itemTarget, nullptr);
                return;
            }
        }
    }

    bool SocketBonusActivated = itemTarget->GemsFitSockets();    //save state of socketbonus
    _player->ToggleMetaGemsActive(slot, false);             //turn off all metagems (except for the target item)

    //if a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met

    //remove ALL enchants
    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
        _player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), false);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (GemEnchants[i])
        {
            itemTarget->SetEnchantment(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT + i), GemEnchants[i], 0, 0, _player->GetGUID());
            if (Item* guidItem = _player->GetItemByGuid(gem_guids[i]))
                _player->DestroyItem(guidItem->GetBagSlot(), guidItem->GetSlot(), true);
        }
    }

    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
        _player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), true);

    bool SocketBonusToBeActivated = itemTarget->GemsFitSockets();//current socketbonus state
    if (SocketBonusActivated ^ SocketBonusToBeActivated)     //if there was a change...
    {
        _player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, false);
        itemTarget->SetEnchantment(BONUS_ENCHANTMENT_SLOT, (SocketBonusToBeActivated ? itemTarget->GetTemplate()->socketBonus : 0), 0, 0, _player->GetGUID());
        _player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, true);
        //it is not displayed, client has an inbuilt system to determine if the bonus is activated
    }

    _player->ToggleMetaGemsActive(slot, true);              //turn on all metagems (except for target item)

    _player->RemoveTradeableItem(itemTarget);
    itemTarget->ClearSoulboundTradeable(_player);           // clear tradeable flag

    itemTarget->SendUpdateSockets();
}

void WorldSession::HandleCancelTempEnchantmentOpcode(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: CMSG_CANCEL_TEMP_ENCHANTMENT");

    uint32 eslot;

    recvData >> eslot;

    // apply only to equipped item
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, eslot))
        return;

    Item* item = GetPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, eslot);

    if (!item)
        return;

    if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
        return;

    GetPlayer()->ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
    item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
}

void WorldSession::HandleItemRefundInfoRequest(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: CMSG_ITEM_REFUND_INFO");

    ObjectGuid guid;
    recvData >> guid;                                      // item guid

    Item* item = _player->GetItemByGuid(guid);
    if (!item)
    {
        LOG_DEBUG("network", "Item refund: item not found!");
        return;
    }

    GetPlayer()->SendRefundInfo(item);
}

void WorldSession::HandleItemRefund(WorldPacket& recvData)
{
    LOG_DEBUG("network", "WORLD: CMSG_ITEM_REFUND");
    ObjectGuid guid;
    recvData >> guid;                                      // item guid

    Item* item = _player->GetItemByGuid(guid);
    if (!item)
    {
        LOG_DEBUG("network", "Item refund: item not found!");
        return;
    }

    // Don't try to refund item currently being disenchanted
    if (_player->GetLootGUID() == guid)
        return;

    GetPlayer()->RefundItem(item);
}

/**
 * Handles the packet sent by the client when requesting information about item text.
 *
 * This function is called when player clicks on item which has some flag set
 */
void WorldSession::HandleItemTextQuery(WorldPacket& recvData )
{
    ObjectGuid itemGuid;
    recvData >> itemGuid;

    LOG_DEBUG("network", "CMSG_ITEM_TEXT_QUERY item: {}", itemGuid.ToString());

    WorldPacket data(SMSG_ITEM_TEXT_QUERY_RESPONSE, 50);        // guess size

    if (Item* item = _player->GetItemByGuid(itemGuid))
    {
        data << uint8(0);                                       // has text
        data << itemGuid;                                       // item guid
        data << item->GetText();
    }
    else
    {
        data << uint8(1);                                       // no text
    }

    SendPacket(&data);
}

bool WorldSession::recoveryItem(Item* pItem)
{
    if (sWorld->getBoolConfig(CONFIG_ITEMDELETE_METHOD)
            && pItem->GetTemplate()->Quality >= sWorld->getIntConfig(CONFIG_ITEMDELETE_QUALITY)
            && pItem->GetTemplate()->ItemLevel >= sWorld->getIntConfig(CONFIG_ITEMDELETE_ITEM_LEVEL))
    {
        CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_RECOVERY_ITEM);

        stmt->SetData(0, pItem->GetOwnerGUID().GetCounter());
        stmt->SetData(1, pItem->GetTemplate()->ItemId);
        stmt->SetData(2, pItem->GetCount());

        CharacterDatabase.Query(stmt);

        return true;
    }

    return false;
}
