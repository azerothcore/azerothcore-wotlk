/*
 * This file is part of the AzerothCore Project. See AUTHORS file for Copyright information
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file SpellProcDataDrivenTest.cpp
 * @brief Comprehensive data-driven tests for ALL 869 spell_proc entries
 *
 * This file auto-tests every spell_proc entry from the database.
 * Data is generated by: src/test/scripts/generate_spell_proc_data.py
 */

#include "ProcEventInfoHelper.h"
#include "SpellInfoTestHelper.h"
#include "SpellMgr.h"
#include "SpellProcTestData.h"
#include "WorldMock.h"
#include "gtest/gtest.h"
#include "gmock/gmock.h"
#include <map>
#include <set>

using namespace testing;

// =============================================================================
// Proc Flag Mappings
// =============================================================================

struct ProcFlagScenario
{
    uint32 procFlag;
    const char* name;
    uint32 defaultHitMask;
    uint32 defaultSpellTypeMask;
    uint32 defaultSpellPhaseMask;
    bool requiresSpellPhase;
};

static const std::vector<ProcFlagScenario> PROC_FLAG_SCENARIOS = {
    { PROC_FLAG_DONE_MELEE_AUTO_ATTACK,         "DoneMeleeAuto",          PROC_HIT_NORMAL, 0, 0, false },
    { PROC_FLAG_TAKEN_MELEE_AUTO_ATTACK,        "TakenMeleeAuto",         PROC_HIT_NORMAL, 0, 0, false },
    { PROC_FLAG_DONE_MAINHAND_ATTACK,           "DoneMainhand",           PROC_HIT_NORMAL, 0, 0, false },
    { PROC_FLAG_DONE_OFFHAND_ATTACK,            "DoneOffhand",            PROC_HIT_NORMAL, 0, 0, false },
    { PROC_FLAG_DONE_RANGED_AUTO_ATTACK,        "DoneRangedAuto",         PROC_HIT_NORMAL, 0, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_RANGED_AUTO_ATTACK,       "TakenRangedAuto",        PROC_HIT_NORMAL, 0, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS,     "DoneSpellMelee",         PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_MELEE_DMG_CLASS,    "TakenSpellMelee",        PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_RANGED_DMG_CLASS,    "DoneSpellRanged",        PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_RANGED_DMG_CLASS,   "TakenSpellRanged",       PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_POS,  "DoneSpellNonePos",       PROC_HIT_NORMAL, PROC_SPELL_TYPE_HEAL, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_POS, "TakenSpellNonePos",      PROC_HIT_NORMAL, PROC_SPELL_TYPE_HEAL, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_NONE_DMG_CLASS_NEG,  "DoneSpellNoneNeg",       PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_NONE_DMG_CLASS_NEG, "TakenSpellNoneNeg",      PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS, "DoneSpellMagicPos",      PROC_HIT_NORMAL, PROC_SPELL_TYPE_HEAL, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_POS,"TakenSpellMagicPos",     PROC_HIT_NORMAL, PROC_SPELL_TYPE_HEAL, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG, "DoneSpellMagicNeg",      PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_SPELL_MAGIC_DMG_CLASS_NEG,"TakenSpellMagicNeg",     PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_DONE_PERIODIC,                  "DonePeriodic",           PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_PERIODIC,                 "TakenPeriodic",          PROC_HIT_NORMAL, PROC_SPELL_TYPE_DAMAGE, PROC_SPELL_PHASE_HIT, true },
    { PROC_FLAG_TAKEN_DAMAGE,                   "TakenDamage",            PROC_HIT_NORMAL, 0, 0, false },
    { PROC_FLAG_KILL,                           "Kill",                   0, 0, 0, false },
    { PROC_FLAG_KILLED,                         "Killed",                 0, 0, 0, false },
    { PROC_FLAG_DEATH,                          "Death",                  0, 0, 0, false },
    { PROC_FLAG_DONE_TRAP_ACTIVATION,           "TrapActivation",         PROC_HIT_NORMAL, 0, PROC_SPELL_PHASE_HIT, true },
};

static const std::vector<std::pair<uint32, const char*>> HIT_MASK_SCENARIOS = {
    { PROC_HIT_NORMAL,      "Normal" },
    { PROC_HIT_CRITICAL,    "Critical" },
    { PROC_HIT_MISS,        "Miss" },
    { PROC_HIT_DODGE,       "Dodge" },
    { PROC_HIT_PARRY,       "Parry" },
    { PROC_HIT_BLOCK,       "Block" },
    { PROC_HIT_EVADE,       "Evade" },
    { PROC_HIT_IMMUNE,      "Immune" },
    { PROC_HIT_DEFLECT,     "Deflect" },
    { PROC_HIT_ABSORB,      "Absorb" },
    { PROC_HIT_REFLECT,     "Reflect" },
    { PROC_HIT_INTERRUPT,   "Interrupt" },
    { PROC_HIT_FULL_BLOCK,  "FullBlock" },
};

// =============================================================================
// Test Fixture for Comprehensive Database Testing
// =============================================================================

class SpellProcDatabaseTest : public ::testing::Test
{
protected:
    void SetUp() override
    {
        _originalWorld = sWorld.release();
        _worldMock = new NiceMock<WorldMock>();
        sWorld.reset(_worldMock);

        static std::string emptyString;
        ON_CALL(*_worldMock, GetDataPath()).WillByDefault(ReturnRef(emptyString));

        // Load all entries from generated data
        _allEntries = GetAllSpellProcTestEntries();

        // Create a default SpellInfo for spell-type procs
        _defaultSpellInfo = SpellInfoBuilder()
            .WithId(99999)
            .WithSpellFamilyName(0)
            .Build();
    }

    void TearDown() override
    {
        IWorld* currentWorld = sWorld.release();
        delete currentWorld;
        _worldMock = nullptr;
        sWorld.reset(_originalWorld);

        delete _defaultSpellInfo;
        _defaultSpellInfo = nullptr;
        delete _damageInfo;
        _damageInfo = nullptr;
        delete _healInfo;
        _healInfo = nullptr;
    }

    /**
     * @brief Find the first matching proc flag scenario for given flags
     */
    ProcFlagScenario const* FindMatchingScenario(uint32 procFlags)
    {
        for (auto const& scenario : PROC_FLAG_SCENARIOS)
        {
            if (procFlags & scenario.procFlag)
                return &scenario;
        }
        return nullptr;
    }

    /**
     * @brief Get effective hit mask for an entry
     */
    uint32 GetEffectiveHitMask(SpellProcTestEntry const& entry, ProcFlagScenario const* scenario)
    {
        if (entry.HitMask != 0)
        {
            // Return first set bit
            for (auto const& [mask, name] : HIT_MASK_SCENARIOS)
            {
                if (entry.HitMask & mask)
                    return mask;
            }
        }
        return scenario ? scenario->defaultHitMask : PROC_HIT_NORMAL;
    }

    /**
     * @brief Get effective spell type mask
     */
    uint32 GetEffectiveSpellTypeMask(SpellProcTestEntry const& entry, ProcFlagScenario const* scenario)
    {
        if (entry.SpellTypeMask != 0)
        {
            if (entry.SpellTypeMask & PROC_SPELL_TYPE_DAMAGE)
                return PROC_SPELL_TYPE_DAMAGE;
            if (entry.SpellTypeMask & PROC_SPELL_TYPE_HEAL)
                return PROC_SPELL_TYPE_HEAL;
            if (entry.SpellTypeMask & PROC_SPELL_TYPE_NO_DMG_HEAL)
                return PROC_SPELL_TYPE_NO_DMG_HEAL;
        }
        return scenario ? scenario->defaultSpellTypeMask : PROC_SPELL_TYPE_MASK_ALL;
    }

    /**
     * @brief Get effective spell phase mask
     */
    uint32 GetEffectiveSpellPhaseMask(SpellProcTestEntry const& entry, ProcFlagScenario const* scenario)
    {
        if (entry.SpellPhaseMask != 0)
            return entry.SpellPhaseMask;
        if (scenario && scenario->requiresSpellPhase)
            return scenario->defaultSpellPhaseMask ? scenario->defaultSpellPhaseMask : PROC_SPELL_PHASE_HIT;
        return 0;
    }

    /**
     * @brief Check if entry requires SpellFamily matching (which we can't test without SpellInfo)
     * Any entry with SpellFamilyName > 0 will cause CanSpellTriggerProcOnEvent to access
     * eventInfo.GetSpellInfo() which returns null in our test, causing a crash.
     */
    bool RequiresSpellFamilyMatch(SpellProcTestEntry const& entry)
    {
        // Skip any entry with SpellFamilyName set - the code will try to access SpellInfo
        return entry.SpellFamilyName != 0;
    }

    /**
     * @brief Check if the proc flags indicate a spell-type event that needs SpellInfo
     */
    bool IsSpellTypeProc(uint32 procFlags)
    {
        return (procFlags & (PERIODIC_PROC_FLAG_MASK | SPELL_PROC_FLAG_MASK | PROC_FLAG_DONE_TRAP_ACTIVATION)) != 0;
    }

    /**
     * @brief Create a ProcEventInfo with proper DamageInfo/HealInfo for spell-type procs
     */
    ProcEventInfo CreateEventInfo(uint32 typeMask, uint32 hitMask, uint32 spellTypeMask, uint32 spellPhaseMask)
    {
        auto builder = ProcEventInfoBuilder()
            .WithTypeMask(typeMask)
            .WithHitMask(hitMask)
            .WithSpellTypeMask(spellTypeMask)
            .WithSpellPhaseMask(spellPhaseMask);

        // For spell-type procs, provide DamageInfo or HealInfo with SpellInfo
        if (IsSpellTypeProc(typeMask))
        {
            if (spellTypeMask & PROC_SPELL_TYPE_HEAL)
            {
                if (!_healInfo)
                    _healInfo = new HealInfo(nullptr, nullptr, 100, _defaultSpellInfo, SPELL_SCHOOL_MASK_HOLY);
                builder.WithHealInfo(_healInfo);
            }
            else
            {
                if (!_damageInfo)
                    _damageInfo = new DamageInfo(nullptr, nullptr, 100, _defaultSpellInfo, SPELL_SCHOOL_MASK_FIRE, SPELL_DIRECT_DAMAGE);
                builder.WithDamageInfo(_damageInfo);
            }
        }

        return builder.Build();
    }

    IWorld* _originalWorld = nullptr;
    NiceMock<WorldMock>* _worldMock = nullptr;
    SpellInfo* _defaultSpellInfo = nullptr;
    DamageInfo* _damageInfo = nullptr;
    HealInfo* _healInfo = nullptr;
    std::vector<SpellProcTestEntry> _allEntries;
};

// =============================================================================
// Comprehensive Tests for All 869 Entries
// =============================================================================

TEST_F(SpellProcDatabaseTest, AllEntriesLoaded)
{
    EXPECT_EQ(_allEntries.size(), 869u) << "Should have all 869 spell_proc entries loaded";
}

TEST_F(SpellProcDatabaseTest, AllEntriesWithProcFlags_PositiveTest)
{
    int totalTested = 0;
    int passed = 0;
    int skippedFamily = 0;
    int skippedNoFlags = 0;

    for (auto const& entry : _allEntries)
    {
        // Skip entries with no ProcFlags (they rely on other conditions)
        if (entry.ProcFlags == 0)
        {
            skippedNoFlags++;
            continue;
        }

        // Skip entries that require SpellFamily matching
        if (RequiresSpellFamilyMatch(entry))
        {
            skippedFamily++;
            continue;
        }

        totalTested++;

        ProcFlagScenario const* scenario = FindMatchingScenario(entry.ProcFlags);
        if (!scenario)
            continue;

        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = CreateEventInfo(
            scenario->procFlag,
            GetEffectiveHitMask(entry, scenario),
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
        {
            passed++;
        }
    }

    // Report statistics
    float passRate = totalTested > 0 ? (float)passed / totalTested * 100 : 0;
    SCOPED_TRACE("Total entries: " + std::to_string(_allEntries.size()));
    SCOPED_TRACE("Tested: " + std::to_string(totalTested));
    SCOPED_TRACE("Passed: " + std::to_string(passed) + " (" + std::to_string((int)passRate) + "%)");
    SCOPED_TRACE("Skipped (SpellFamily): " + std::to_string(skippedFamily));
    SCOPED_TRACE("Skipped (NoFlags): " + std::to_string(skippedNoFlags));

    // Expect high pass rate for entries we can test
    EXPECT_GT(passed, totalTested / 2) << "At least half of tested entries should pass";
}

TEST_F(SpellProcDatabaseTest, AllEntriesWithProcFlags_NegativeTest)
{
    int totalTested = 0;
    int correctlyRejected = 0;

    for (auto const& entry : _allEntries)
    {
        if (entry.ProcFlags == 0)
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        // Find a flag that's NOT in this entry's ProcFlags
        uint32 wrongFlag = 0;
        for (auto const& scenario : PROC_FLAG_SCENARIOS)
        {
            if (!(entry.ProcFlags & scenario.procFlag) && scenario.procFlag != PROC_FLAG_KILL)
            {
                wrongFlag = scenario.procFlag;
                break;
            }
        }

        if (wrongFlag == 0)
            continue;

        totalTested++;

        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = ProcEventInfoBuilder()
            .WithTypeMask(wrongFlag)
            .WithHitMask(PROC_HIT_NORMAL)
            .Build();

        if (!sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
        {
            correctlyRejected++;
        }
    }

    float rejectRate = totalTested > 0 ? (float)correctlyRejected / totalTested * 100 : 0;
    SCOPED_TRACE("Tested: " + std::to_string(totalTested));
    SCOPED_TRACE("Rejected: " + std::to_string(correctlyRejected) + " (" + std::to_string((int)rejectRate) + "%)");

    EXPECT_GT(rejectRate, 90.0f) << "Most entries should reject non-matching proc flags";
}

// =============================================================================
// Tests by Proc Flag Type
// =============================================================================

TEST_F(SpellProcDatabaseTest, MeleeProcs_AllTriggerOnMelee)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.ProcFlags & PROC_FLAG_DONE_MELEE_AUTO_ATTACK))
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        uint32 hitMask = entry.HitMask != 0 ? (entry.HitMask & -entry.HitMask) : PROC_HIT_NORMAL;

        auto eventInfo = ProcEventInfoBuilder()
            .WithTypeMask(PROC_FLAG_DONE_MELEE_AUTO_ATTACK)
            .WithHitMask(hitMask)
            .Build();

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Melee procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_EQ(passed, tested);
}

TEST_F(SpellProcDatabaseTest, SpellDamageProcs_AllTriggerOnSpellDamage)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.ProcFlags & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG))
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        uint32 hitMask = entry.HitMask != 0 ? (entry.HitMask & -entry.HitMask) : PROC_HIT_NORMAL;
        uint32 spellTypeMask = entry.SpellTypeMask != 0 ? entry.SpellTypeMask : PROC_SPELL_TYPE_DAMAGE;
        uint32 spellPhaseMask = entry.SpellPhaseMask != 0 ? entry.SpellPhaseMask : PROC_SPELL_PHASE_HIT;

        auto eventInfo = CreateEventInfo(
            PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_NEG,
            hitMask,
            spellTypeMask,
            spellPhaseMask);

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Spell damage procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_GT(passed, 0);
}

TEST_F(SpellProcDatabaseTest, HealProcs_AllTriggerOnHeal)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.ProcFlags & PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS))
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        uint32 hitMask = entry.HitMask != 0 ? (entry.HitMask & -entry.HitMask) : PROC_HIT_NORMAL;
        uint32 spellTypeMask = entry.SpellTypeMask != 0 ? entry.SpellTypeMask : PROC_SPELL_TYPE_HEAL;
        uint32 spellPhaseMask = entry.SpellPhaseMask != 0 ? entry.SpellPhaseMask : PROC_SPELL_PHASE_HIT;

        auto eventInfo = CreateEventInfo(
            PROC_FLAG_DONE_SPELL_MAGIC_DMG_CLASS_POS,
            hitMask,
            spellTypeMask,
            spellPhaseMask);

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Heal procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_GT(passed, 0);
}

TEST_F(SpellProcDatabaseTest, PeriodicProcs_AllTriggerOnPeriodic)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.ProcFlags & PROC_FLAG_DONE_PERIODIC))
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        uint32 hitMask = entry.HitMask != 0 ? (entry.HitMask & -entry.HitMask) : PROC_HIT_NORMAL;
        uint32 spellTypeMask = entry.SpellTypeMask != 0 ? entry.SpellTypeMask : PROC_SPELL_TYPE_DAMAGE;
        uint32 spellPhaseMask = entry.SpellPhaseMask != 0 ? entry.SpellPhaseMask : PROC_SPELL_PHASE_HIT;

        auto eventInfo = CreateEventInfo(
            PROC_FLAG_DONE_PERIODIC,
            hitMask,
            spellTypeMask,
            spellPhaseMask);

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Periodic procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_GT(passed, 0);
}

TEST_F(SpellProcDatabaseTest, KillProcs_AllTriggerOnKill)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.ProcFlags & PROC_FLAG_KILL))
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = ProcEventInfoBuilder()
            .WithTypeMask(PROC_FLAG_KILL)
            .WithHitMask(PROC_HIT_NORMAL)
            .Build();

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Kill procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    // Kill events always proc
    EXPECT_EQ(passed, tested);
}

// =============================================================================
// Tests by Hit Mask Type
// =============================================================================

TEST_F(SpellProcDatabaseTest, CritOnlyProcs_OnlyTriggerOnCrit)
{
    int tested = 0, critPassed = 0, normalRejected = 0;

    for (auto const& entry : _allEntries)
    {
        // Only entries with EXACTLY crit requirement
        if (entry.HitMask != PROC_HIT_CRITICAL)
            continue;
        if (entry.ProcFlags == 0)
            continue;
        if (RequiresSpellFamilyMatch(entry))
            continue;

        ProcFlagScenario const* scenario = FindMatchingScenario(entry.ProcFlags);
        if (!scenario)
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        // Test crit - should pass
        auto critEvent = CreateEventInfo(
            scenario->procFlag,
            PROC_HIT_CRITICAL,
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, critEvent))
            critPassed++;

        // Test normal - should fail
        auto normalEvent = CreateEventInfo(
            scenario->procFlag,
            PROC_HIT_NORMAL,
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (!sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, normalEvent))
            normalRejected++;
    }

    SCOPED_TRACE("Crit-only procs: " + std::to_string(tested) + " tested");
    SCOPED_TRACE("Crit passed: " + std::to_string(critPassed));
    SCOPED_TRACE("Normal rejected: " + std::to_string(normalRejected));

    if (tested > 0)
    {
        // Most crit-only entries should work, but some may have additional requirements
        EXPECT_GT(critPassed, 0) << "At least some crit-only procs should trigger on crits";
        EXPECT_GT(normalRejected, 0) << "At least some crit-only procs should NOT trigger on normal hits";
    }
}

TEST_F(SpellProcDatabaseTest, DodgeProcs_OnlyTriggerOnDodge)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.HitMask & PROC_HIT_DODGE))
            continue;
        if (entry.ProcFlags == 0)
            continue;

        ProcFlagScenario const* scenario = FindMatchingScenario(entry.ProcFlags);
        if (!scenario)
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = CreateEventInfo(
            scenario->procFlag,
            PROC_HIT_DODGE,
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Dodge procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_EQ(passed, tested);
}

TEST_F(SpellProcDatabaseTest, ParryProcs_OnlyTriggerOnParry)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.HitMask & PROC_HIT_PARRY))
            continue;
        if (entry.ProcFlags == 0)
            continue;

        ProcFlagScenario const* scenario = FindMatchingScenario(entry.ProcFlags);
        if (!scenario)
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = CreateEventInfo(
            scenario->procFlag,
            PROC_HIT_PARRY,
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Parry procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_EQ(passed, tested);
}

TEST_F(SpellProcDatabaseTest, BlockProcs_OnlyTriggerOnBlock)
{
    int tested = 0, passed = 0;

    for (auto const& entry : _allEntries)
    {
        if (!(entry.HitMask & PROC_HIT_BLOCK))
            continue;
        if (entry.ProcFlags == 0)
            continue;

        ProcFlagScenario const* scenario = FindMatchingScenario(entry.ProcFlags);
        if (!scenario)
            continue;

        tested++;
        SpellProcEntry procEntry = entry.ToSpellProcEntry();

        auto eventInfo = CreateEventInfo(
            scenario->procFlag,
            PROC_HIT_BLOCK,
            GetEffectiveSpellTypeMask(entry, scenario),
            GetEffectiveSpellPhaseMask(entry, scenario));

        if (sSpellMgr->CanSpellTriggerProcOnEvent(procEntry, eventInfo))
            passed++;
    }

    SCOPED_TRACE("Block procs: " + std::to_string(tested) + " tested, " + std::to_string(passed) + " passed");
    if (tested > 0)
        EXPECT_EQ(passed, tested);
}

// =============================================================================
// Tests by Spell Family (Class-Specific)
// =============================================================================

TEST_F(SpellProcDatabaseTest, GroupBySpellFamily_Statistics)
{
    std::map<uint32, std::string> familyNames = {
        {0, "Generic"}, {3, "Mage"}, {4, "Warrior"}, {5, "Warlock"},
        {6, "Priest"}, {7, "Druid"}, {8, "Rogue"}, {9, "Hunter"},
        {10, "Paladin"}, {11, "Shaman"}, {15, "DeathKnight"}
    };

    std::map<uint32, int> familyCounts;
    for (auto const& entry : _allEntries)
    {
        familyCounts[entry.SpellFamilyName]++;
    }

    for (auto const& [family, count] : familyCounts)
    {
        std::string name = familyNames.count(family) ? familyNames[family] : "Unknown(" + std::to_string(family) + ")";
        SCOPED_TRACE("SpellFamily " + name + ": " + std::to_string(count) + " entries");
    }

    EXPECT_GT(familyCounts.size(), 0u);
}

TEST_F(SpellProcDatabaseTest, GroupByProcFlags_Statistics)
{
    std::map<uint32, int> flagCounts;
    for (auto const& entry : _allEntries)
    {
        flagCounts[entry.ProcFlags]++;
    }

    SCOPED_TRACE("Unique ProcFlags patterns: " + std::to_string(flagCounts.size()));
    EXPECT_GT(flagCounts.size(), 0u);
}

TEST_F(SpellProcDatabaseTest, GroupByHitMask_Statistics)
{
    std::map<uint32, int> hitCounts;
    for (auto const& entry : _allEntries)
    {
        hitCounts[entry.HitMask]++;
    }

    SCOPED_TRACE("Unique HitMask patterns: " + std::to_string(hitCounts.size()));
    EXPECT_GT(hitCounts.size(), 0u);
}

// =============================================================================
// Data Integrity Tests
// =============================================================================

TEST_F(SpellProcDatabaseTest, ToSpellProcEntry_ConversionCorrect)
{
    for (auto const& entry : _allEntries)
    {
        SpellProcEntry converted = entry.ToSpellProcEntry();

        EXPECT_EQ(converted.SchoolMask, entry.SchoolMask);
        EXPECT_EQ(converted.SpellFamilyName, entry.SpellFamilyName);
        EXPECT_EQ(converted.SpellFamilyMask[0], entry.SpellFamilyMask0);
        EXPECT_EQ(converted.SpellFamilyMask[1], entry.SpellFamilyMask1);
        EXPECT_EQ(converted.SpellFamilyMask[2], entry.SpellFamilyMask2);
        EXPECT_EQ(converted.ProcFlags, entry.ProcFlags);
        EXPECT_EQ(converted.SpellTypeMask, entry.SpellTypeMask);
        EXPECT_EQ(converted.SpellPhaseMask, entry.SpellPhaseMask);
        EXPECT_EQ(converted.HitMask, entry.HitMask);
        EXPECT_EQ(converted.AttributesMask, entry.AttributesMask);
        EXPECT_EQ(converted.Cooldown.count(), static_cast<int64>(entry.Cooldown));
        EXPECT_FLOAT_EQ(converted.Chance, entry.Chance);
    }
}
